#!/usr/bin/env python3
"""
atsr-generate-tests: Generate initial test templates from code analysis
Usage: atsr-generate-tests <analysis-json> [--output-dir tests/]
Input: JSON from atsr-analyze-code
Output: Creates test files with basic test templates
"""

import sys
import os
import json
from pathlib import Path
from typing import Dict, List, Any

PYTHON_TEST_TEMPLATE = '''"""
Tests for {module_name}
Auto-generated by atsr-generate-tests
"""

import pytest
from {import_path} import {imports}


{test_functions}
'''

PYTHON_FUNCTION_TEST = '''def {test_name}():
    """Test {function_name} with basic input"""
    # TODO: Add test implementation
    # Test basic functionality
    result = {function_name}({sample_args})
    assert result is not None  # Replace with actual assertion

    # TODO: Test edge cases
    # - Boundary values
    # - Error conditions
    # - Invalid input
'''

PYTHON_METHOD_TEST = '''def {test_name}():
    """Test {class_name}.{method_name}"""
    # TODO: Add test implementation
    instance = {class_name}()
    result = instance.{method_name}({sample_args})
    assert result is not None  # Replace with actual assertion
'''

JS_TEST_TEMPLATE = '''/**
 * Tests for {module_name}
 * Auto-generated by atsr-generate-tests
 */

import {{ {imports} }} from '{import_path}';

describe('{module_name}', () => {{
{test_functions}
}});
'''

JS_FUNCTION_TEST = '''  test('{test_description}', () => {{
    // TODO: Add test implementation
    const result = {function_name}({sample_args});
    expect(result).toBeDefined();  // Replace with actual assertion

    // TODO: Test edge cases
    // - Boundary values
    // - Error conditions
    // - Invalid input
  }});
'''

def generate_sample_args(args: List[str], language: str) -> str:
    """Generate sample argument list for function calls"""
    if not args:
        return ''

    if language == 'python':
        return ', '.join([f"None  # TODO: provide {arg}" for arg in args])
    else:  # JavaScript/TypeScript
        return ', '.join([f"null  /* TODO: provide {arg} */" for arg in args])

def group_functions_by_file(functions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group functions by their source file"""
    grouped = {}
    for func in functions:
        file_path = func['file']
        if file_path not in grouped:
            grouped[file_path] = []
        grouped[file_path].append(func)
    return grouped

def generate_python_tests(functions: List[Dict[str, Any]], source_file: str, output_dir: str):
    """Generate pytest test file"""

    # Determine module name and import path
    source_path = Path(source_file)
    module_name = source_path.stem

    # Calculate relative import path
    parts = source_path.parts
    if 'src' in parts:
        idx = parts.index('src')
        import_parts = parts[idx+1:-1] + (module_name,)
    else:
        import_parts = (module_name,)
    import_path = '.'.join(import_parts)

    # Collect all imports needed
    imports = set()
    test_functions_code = []

    for func in functions:
        if func['type'] == 'function':
            imports.add(func['name'])
            sample_args = generate_sample_args(func['args'], 'python')
            test_code = PYTHON_FUNCTION_TEST.format(
                test_name=func['suggested_test_name'],
                function_name=func['name'],
                sample_args=sample_args
            )
            test_functions_code.append(test_code)

        elif func['type'] == 'method':
            class_name = func['class']
            method_name = func['name'].split('.')[-1]
            imports.add(class_name)
            sample_args = generate_sample_args(func['args'], 'python')
            test_code = PYTHON_METHOD_TEST.format(
                test_name=func['suggested_test_name'],
                class_name=class_name,
                method_name=method_name,
                sample_args=sample_args
            )
            test_functions_code.append(test_code)

    # Generate full test file content
    content = PYTHON_TEST_TEMPLATE.format(
        module_name=module_name,
        import_path=import_path,
        imports=', '.join(sorted(imports)),
        test_functions='\n\n'.join(test_functions_code)
    )

    # Write test file
    test_filename = f"test_{module_name}.py"
    test_path = os.path.join(output_dir, test_filename)

    os.makedirs(output_dir, exist_ok=True)

    with open(test_path, 'w') as f:
        f.write(content)

    return test_path

def generate_javascript_tests(functions: List[Dict[str, Any]], source_file: str, output_dir: str):
    """Generate jest/mocha test file"""

    source_path = Path(source_file)
    module_name = source_path.stem
    extension = source_path.suffix

    # Calculate import path
    import_path = './' + '/'.join(source_path.parts[-2:]).replace(extension, '')

    # Collect imports and test functions
    imports = set()
    test_functions_code = []

    for func in functions:
        func_name = func['name'].split('.')[-1]  # Handle methods
        imports.add(func_name)

        sample_args = generate_sample_args(func['args'], 'javascript')
        test_code = JS_FUNCTION_TEST.format(
            test_description=f"should test {func_name}",
            function_name=func_name,
            sample_args=sample_args
        )
        test_functions_code.append(test_code)

    # Generate full test file
    content = JS_TEST_TEMPLATE.format(
        module_name=module_name,
        import_path=import_path,
        imports=', '.join(sorted(imports)),
        test_functions='\n'.join(test_functions_code)
    )

    # Write test file
    test_filename = f"{module_name}.test{extension}"
    test_path = os.path.join(output_dir, test_filename)

    os.makedirs(output_dir, exist_ok=True)

    with open(test_path, 'w') as f:
        f.write(content)

    return test_path

def main():
    if len(sys.argv) < 2 or sys.argv[1] in ['-h', '--help']:
        print(__doc__)
        sys.exit(0)

    analysis_file = sys.argv[1]
    output_dir = 'tests'

    # Parse optional output directory
    if len(sys.argv) > 2 and sys.argv[2] == '--output-dir' and len(sys.argv) > 3:
        output_dir = sys.argv[3]

    if not os.path.isfile(analysis_file):
        print(f"Error: Analysis file '{analysis_file}' not found", file=sys.stderr)
        sys.exit(1)

    # Load analysis
    with open(analysis_file, 'r') as f:
        analysis = json.load(f)

    if 'functions' not in analysis:
        print("Error: Invalid analysis JSON - missing 'functions' key", file=sys.stderr)
        sys.exit(1)

    # Group functions by source file
    grouped = group_functions_by_file(analysis['functions'])

    generated_files = []

    # Generate test files
    for source_file, functions in grouped.items():
        if not functions:
            continue

        # Detect language from file extension
        ext = Path(source_file).suffix

        try:
            if ext == '.py':
                test_path = generate_python_tests(functions, source_file, output_dir)
                generated_files.append(test_path)
            elif ext in ['.js', '.ts', '.jsx', '.tsx']:
                test_path = generate_javascript_tests(functions, source_file, output_dir)
                generated_files.append(test_path)
            else:
                print(f"Warning: Unsupported file type {ext} for {source_file}", file=sys.stderr)

        except Exception as e:
            print(f"Error generating tests for {source_file}: {e}", file=sys.stderr)

    # Output summary
    result = {
        'generated_files': generated_files,
        'count': len(generated_files),
        'output_dir': output_dir
    }

    print(json.dumps(result, indent=2))

if __name__ == '__main__':
    main()
